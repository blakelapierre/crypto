<!doctype html>
<html>
  <head>
    <title>crypto accounts</title>

    <script>
      const E = (...args) => document.createElement(...args);
      const ac = (e1, e2) => e1.appendChild(e2);

      const TH = header => {
        const th = E('th');
        th.innerText = header;
        return th;
      };

      const TD = text => {
        const td = E('td');
        td.innerText = text;
        return td;
      };

      const ws = new WebSocket(`ws://${window.location.hostname}:8081`);

      const exchangeEls = {};

      let balances = {}, markets = {}, tickers = {}, targets = {}, targetEls = {};
      ws.addEventListener('message', event => {
        const message = JSON.parse(event.data);
        console.log(message);

        const [messageType, data] = message;

        switch (messageType) {
          case 'exchanges':
            const eEl = E('exchanges');

            data.forEach(({nickname}) => {
              const el = E('exchange');
              el.innerText = nickname;

              exchangeEls[nickname] = el;
              ac(eEl, el);

              targets[nickname] = {};
              targetEls[nickname] = {};
            });

            ac(document.body, eEl);
            break;
          case 'balances':
            balances[data.exchange] = data;

            buildExchange(data.exchange);
            break;
          case 'markets':
            markets[data.exchange] = data;

            break;
          case 'tickers':
            tickers[data.exchange] = data;

            buildExchange(data.exchange);
            break;
        }
      });

      function buildExchange(exchange) {
        const id = exchange;
        const el = exchangeEls[id];

        const bEl = E('balances');

        el.innerHTML = '';

        const header = E('exchange-header');

        const name = E('exchange');
        name.innerText = id;

        const targetPortfolio = E('select');
        const label = E('label');
        label.innerText = 'Target Porfolios:';

        ac(header, name);
        ac(header, label);
        ac(header, targetPortfolio);
        ac(el, header);

        const table = createBalanceTable(id, balances[id].balances, '$');
        ac(el, table);

        ac(el, bEl);
      }

      function createBalanceTable(exchange, {total, free, used}, sortBy) {
        const table = E('table');
        const head = E('thead');
        const body = E('tbody');
        const foot = E('tfoot');
        ac(table, head);
        ac(table, body);
        ac(table, foot);

        const row = E('tr');

        ac(row, TH('coin'));
        ac(row, TH('total'));
        ac(row, TH('free'));
        ac(row, TH('used'));
        ac(row, TH('$ value'));
        ac(row, TH('portfolio %'));
        ac(row, TH('target %'));
        ac(row, TH('target weight'));
        ac(row, TH('$ diff'));
        ac(head, row);


        let keys = Object.keys(total);

        let dollarValues = {};
        const portfolioWeight = {};
        let totalDollarValue = 0;
        keys.forEach(key => {
          const t = tickers[exchange];
          if (!t) return;
          const ticker = t.tickers[`${key}/USD`] || t.tickers[`${key}/USDT`];

          if (ticker) {
            const value = (total[key] || 0) * ticker.bid;
            dollarValues[key] = value;
            totalDollarValue += value;
          }
          else if (key === 'USDT' || key === 'USD') {
            const value = total[key] || 0;
            dollarValues[key] = value;
            totalDollarValue += value;
          }
          else {
            dollarValues[key] = '';
          }
        });

        if (totalDollarValue > 0) {
          keys.forEach(key => {
            portfolioWeight[key] = dollarValues[key] / totalDollarValue;
          });
        }


        if (sortBy) keys = keys.sort((a, b) => {
          switch (sortBy) {
            case 'key': return a < b ? -1 : 1;
            case 'total': 
              return total[a] > total[b] ? -1 : (total[a] < total[b] ? 1 : (a < b ? -1 : 1));
            case 'free': 
              return free[a] > free[b] ? -1 : (free[a] < free[b] ? 1 : (a < b ? -1 : 1));
            case 'used': 
              return used[a] > used[b] ? -1 : (used[a] < used[b] ? 1 : (a < b ? -1 : 1));
            case '$': 
              return dollarValues[a] > dollarValues[b] ? -1 : (dollarValues[a] < dollarValues[b] ? 1 : (a < b ? -1 : 1));
          }
        });

        const targetDiffEls = {};

        keys.forEach(key => {
          const tr = E('tr');

          ac(tr, TD(key));
          ac(tr, TD(total[key] || 0));
          ac(tr, TD(free[key] || (free[key] === undefined ? total[key] : 0)));
          ac(tr, TD(used[key] || 0));
          ac(tr, TD('$' + (dollarValues[key] || 0).toFixed(2)));
          

          if (totalDollarValue > 0) {
            const weight = parseFloat(portfolioWeight[key] * 100).toFixed(2);
            const weightEl = TD('');

            const weightDisplayEl = E('weight');
            weightDisplayEl.style.width = `${weight}%`;

            const weightSpanEl = E('div');
            weightSpanEl.innerText = weight + '%';

            ac(weightEl, weightSpanEl);
            ac(weightEl, weightDisplayEl);

            ac(tr, weightEl);
          }
          else ac(tr, TD(''));

          const target = E('input');
          target.type = 'number';
          target.min = 0;
          target.max = 100;
          target.step = 0.01;

          targetEls[exchange][key] = target;

          target.addEventListener('change', event => {
            const newValue = event.target.value;
            const diff = targets[exchange][key] - newValue;

            const weightsWithoutKey = {};
            const totalWithoutKey = 100 - targets[exchange][key];
            targets[exchange][key] = newValue;

            keys.forEach(pKey => {
              if (key === pKey) return;
              weightsWithoutKey[pKey] = targets[exchange][pKey] / totalWithoutKey;
            });

            keys.forEach(pKey => {
              if (key === pKey) return;
              const t = (targets[exchange][pKey] = parseFloat(targets[exchange][pKey]) + diff * weightsWithoutKey[pKey]);
              targetEls[exchange][pKey].value = t;

              const targetDiff = dollarValues[pKey] - targets[exchange][pKey] / 100 * totalDollarValue ;

              targetDiffEls[pKey].innerText = `$${-targetDiff.toFixed(2)}`;
            });

            const targetTotal = keys.reduce((acc, key) => acc + parseFloat(targets[exchange][key]), 0);

            targetTotalEl.innerText = targetTotal.toFixed(2) + '%';

            const targetDiff = dollarValues[key] - targets[exchange][key] / 100 * totalDollarValue ;

            targetDiffEls[key].innerText = `$${-targetDiff.toFixed(2)}`;

          });

          if (totalDollarValue > 0) {
            targets[exchange][key] = targets[exchange][key] || (dollarValues[key] / totalDollarValue * 100).toFixed(2);
            target.value = targets[exchange][key];
          }

          const targetEl = TD('');
          ac(targetEl, target);

          ac(tr, targetEl);


          const targetWeightInput = E('input');
          targetWeightInput.type = 'number';
          targetWeightInput.min = 0;
          targetWeightInput.max = 99999999;
          targetWeightInput.step = 1;

          targetWeightInput.value = 0;

          const targetWeightEl = TD('');
          ac(targetWeightEl, targetWeightInput);

          ac(tr, targetWeightEl);


          if (totalDollarValue > 0) {
            const targetDiff = dollarValues[key] - targets[exchange][key] / 100 * totalDollarValue ;
            const targetDiffEl = TD(`$${-targetDiff.toFixed(2)}`);
            targetDiffEls[key] = targetDiffEl;
            ac(tr, targetDiffEl);
          }
          else {
            ac(tr, TD(''));
          }


          ac(body, tr);
        });

        const portfolioTotal = keys.reduce((acc, key) => acc + parseFloat(portfolioWeight[key]), 0);
        const targetTotal = keys.reduce((acc, key) => acc + parseFloat(targets[exchange][key]), 0);

        const targetTotalEl = TH(targetTotal.toFixed(2) + '%');

        const frow = E('tr');

        ac(foot, frow);

        ac(frow, TH('TOTAL:'));
        ac(frow, TH(''));
        ac(frow, TH(''));
        ac(frow, TH(''));
        ac(frow, TH('$' + totalDollarValue.toFixed(2)));
        ac(frow, TH((portfolioTotal * 100).toFixed(2) + '%'));
        ac(frow, targetTotalEl);

        return table;
      }
    </script>

    <style>
      exchanges {
        display: flex;
      }

      exchange {
        display: block;

        padding: 0.25em;
        margin: 0.25em;

        background-color: #eee;
      }

      balances {
        display: block;
      }

      coin {
        display: block;
      }

      exchange table {
        padding: 0.1em;

        border: solid 1px #999;

        border-collapse: collapse;
      }

      exchange table tr {
        border-bottom: solid 1px #333;
      }

      exchange table td {
        position: relative;

        padding: 0.25em;

        border-left: solid 1px #999;
      }

      weight {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        background-color: rgba(0.8, 0.8, 0.8, 0.2);
      }
    </style>
  </head>
  <body>
  </body>
</html>